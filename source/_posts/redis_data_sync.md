---
title: 【Redis】数据同步
date: 2023-11-28 19:14:34
tags: [Redis, SQL]
---

## Redis 的高可靠性

- 数据尽量少丢失（RDB，AOF）
- 服务尽量少中断（将一份数据保存在多个实例上，增加副本冗余量）

Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式

- 读操作：主库、从库都可以接收
- 写操作：首先到主库执行，然后，主库将写操作同步给从库

为什么要采用读写分离的方式

如果非要保持这个数据在三个实例上一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，会带来巨额的开销

采用读写分离之后，所有数据的修改只会在主库上进行，不用协调三个实例。主库有了最新的数据后，会同步给从库

## 主从库之间是如何同步的

当启动多个 Redis 实例的时候，相互之间就可以通过 replicaof 命令形成主库和从库的关系

之后会按照三个阶段完成第一次同步

### 第一阶段：建立连接，协商同步

从库：执行 slaveof 建立连接，后保存主节点信息

主库：执行 bgsave 生成 RDB

从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令参数来启动复制，psync 命令包含了主库 runID（每个实例启动时生成的随机 ID 用来唯一标记这个实例，第一次复制时不知道主库的 runID 所以设为 "?"） 和复制进度 offset（-1，表示第一次复制） 两个参数

主库收到 psync 命令后，会用 FULLRESYNC（表示第一次复制采用的全量复制） 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库

### 第二阶段：主库同步数据给从库

主库：发送 RDB 给从库

从库：清空现有数据，加载 RDB 文件

在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求

但是这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中，为了主从库数据一致性，主库会在内存中用专门的 replication buffer 记录 RDB 文件生成后收到的所有写操作

### 第三阶段：主库发送新写命令给从库

主库：发送 repl buffer

从库：加载 repl buffer 

## 主从级联模式分担全量复制时的主库压力

一次全量复制中，对主库来说有两个耗时的操作：生成 RBD 和传输 RDB

如果从库数量很多，都要和主库进行全量复制的话，会导致主库忙于 fork 子进程（会造成主线程阻塞）生成 RDB 文件

另外传输 RDB 文件也会占用主库的网络带宽，给主库的资源使用带来压力

### 解决方式

通过“主 - 从 - 从”模式将主库生成和传输 RDB 的压力，以级联的方式分散到从库上

在部署主从集群的时候，可以手动选择一个从库，用于级联其他的库，然后选择一些从库，在这些从库上执行

```
replicaof 所选从库的 IP 6379
```

一旦主从库完成了全量复制，它们之间会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库

这个过程也称作**基于长连接的命令传播**

这个过程中存在这风险点，最常见的就是**网络断连或阻塞**

## 主从库之间网络断了怎么办

### 缓冲区

网络断了之后，主从库会采用增量复制的方式继续同步，只会把主从库网络断连期间主库收到的命令同步给从库

只要有从库存在，这个 repl_backlog_buffer 就会存在

主库的所有写命令除了传播给从库之外，都会在这个 repl_backlog_buffer 中记录一份，缓存起来

只有预先缓存了这些命令，当从库断连后，从库重新发送 psync $master_runid $offset

主库才能通过 $offset 在 repl_backlog_buffer 中找到从库断开的位置，只发送 $offset 之后的增量数据给从库即可。

这是个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置

刚开始时，主库和从库的读写位置在一起，随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置

我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset 主库接收的新的操作越多，这个值就越大

从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，已复制偏移量 slave_repl_offset 不断增加

正常情况下，两个偏移量基本相等

### 主从库连接恢复后

从库首先会发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库

主库会判断 slava_repl_offset 和 master_repl_offset 之间的差距

一般来说 master_repl_offset 会大于 slave_repl_offset 主库只用把之间的命令操作同步给从库就行

### 注意

repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入覆盖之前的操作

如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被新写的操作覆盖了，导致主从库间的数据不一致


repl_backlog_buffer：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。

如果从库断开时间太久，repl_backlog_buffer 环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步

所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量同步的概率。而在 repl_backlog_buffer 中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。

replication buffer：Redis 和客户端通信也好，和从库通信也好，Redis 都需要给分配一个内存 buffer 进行数据交互

客户端是一个 client，从库也是一个 client，我们每个 client 连上 Redis 后，Redis 都会分配一个 client buffer，所有数据交互都是通过这个 buffer 进行的

Redis 先把数据写到这个 buffer 中，然后再把 buffer 中的数据发到 client socket 中再通过网络发送出去，这样就完成了数据交互。

所以主从在增量同步时，从库作为一个 client，也会分配一个 buffer，只不过这个 buffer 专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做 replication buffer。

