---
title: 【Redis】高性能 IO 模型
date: 2023-11-20 14:58:26
tags: [Redis, SQL, IO]
---

## 为什么单线程的 Redis 能那么快

事实： Redis 是单线程，主要是指 Redis 的网络 IO 和键值读写是由一个线程来完成的。其他功能如持久化、异步删除、集群数据同步等，是由额外的线程执行的。

## 为什么使用单线程

### 多线程的开销

使用多线程，可以增加系统的吞吐率（能够同时处理的请求数），或是增加系统的扩展性。

现实会存在瓶颈，系统中通常会存在被多线程同时访问的共享资源，多个线程要修改这个共享资源时，为保证这个共享资源的正确性，需要额外的机制，也会带来额外的开销。

这就是多线程编程模式面临的共享资源的并发访问控制问题。

如果只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统的吞吐率并没有随着线程的增加而增加。

多线程开发一般会引入同步原语来保护共享资源的并发访问，会降低系统代码的易调试性和可维护性。

为了避免这些问题 Redis 直接采用了单线程模式

## 为什么那么快

一方面，Redis 大部分操作在内存上完成，而且采用了高效的数据结构，例如哈希表和跳表

另一方面，Redis 采用多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率

## 基本 IO 模型与阻塞点

处理一个 Get 需要的流程，潜在的阻塞点
- 网络 IO 处理
  - bind/listen
  - accept 当有一个客户端有连接请求但未能成功建立连接时，会阻塞在此
  - recv 从一个客户端读取数据，数据一直没送达，也会阻塞在此
  - parse
- 键值数据读写
  - get
- 网络 IO 处理
  - send

这会导致 Redis 整个线程阻塞，幸运的是，socket 网络模型本身支持非阻塞模式

## 非阻塞模式

如果要使用 socket 非阻塞模式，就要了解三个函数的调用返回类型和设置模式

在 socket 模型中，不同操作调用后会返回不同的套接字类型

socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，这时可以监听来自客户端的连接请求

最后调用 accept() 方法接收到达的客户端连接，返回已连接套接字

| 调用方法 | 返回套接字类型 | 非阻塞模式 | 效果 |
|  ----  | ----  |  ----  | ----  |
| socket() | 主动套接字 |  |  |
| listen() | 监听套接字 | 可设置 | accept() 非阻塞 |
| accept() | 已连接套接字 | 可设置 | send()/recv() 非阻塞 |

非阻塞模式中，当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作。

但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis

类似的，调用 recv() 后，数据一直没有到达， Redis 线程同样可以返回处理其他操作，也需要有机制监听已连接套接字，并在有数据时通知 Redis

## 基于多路复用的高性能 IO 模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，即 select/epoll 机制。

Redis 只运行单线程的情况下，机制允许内核中同时存在多个监听套接字和已连接套接字。

内核会一直监听这些套接字上的连接请求或数据请求，一旦有请求到达，就会交给 Redis 处理。

为了在请求到达时能通知到 Redia 线程，select/epoll 提供了基于事件的回调机制，针对不同事件的发生，调用相应的处理函数。

![基于多路复用的 Redis 高性能 IO 模型](image.png)

这些事件会被放入一个事件队列，Redis 单线程对该事件队列不断进行处理，Redis 无需一直轮询是否有请求发生

Redis 对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调

即使你的应用场景下部署了不同的操作系统，多路复用机制也是适用的，这个机制的实现有很多种，可以根据 Redis 实际运行的操作系统，选择相应的多路复用实现

