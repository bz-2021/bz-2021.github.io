---
title: 【C++笔记】深入内存管理
date: 2023-04-18 9:48:00
tags: [C++]
---

## ELF文件结构

![C++程序的内存分布](https://pic.leetcode-cn.com/1661172875-aSnoQn-1_2_1.png)

这是ELF文件的构成，ELF全称可执行与可链接格式 (Executable and Linkable Format)。

<!-- more-->

.text section，存放可执行程序的机器码。

.rodata section，只读数据节，数据不可修改，存放程序中的常量。

.data section，存放已初始化的全局和静态变量，常量，比如字符串常量。

.bss(Block started by symbol) section，存放未初始化的全局和静态变量（默认设为0）。

操作系统加载ELF文件时，会依照次序读取每个节中的内容，加载到内存，同时分配到栈空间，并将`pc`寄存器指向代码段的起始位置，然后启动进程。


## 内存分区

**代码区**
`.text`段，存放代码。不允许修改，存放二进制文件。

**常量存储区** 
`.rodata`段，常量，程序结束后自动释放。

**全局/静态存储器区**
`.bss`段和`.data`段，存放全局变量和静态变量，程序结束后操作系统自动释放，未初始化的放在`.bss`段，初始化的放在`.data`段中。

**栈空间**
存放局部变量、函数参数、返回地址等，栈空间在程序的生存空间一直存在。

**堆空间**
动态申请的内存空间，由malloc和new分配的内存块，由程序控制分配和释放。

## 栈与堆

- 操作系统中的「Stack Machine」

堆与栈的优缺点：

- 申请方式：栈是编译时由编译器分配的，一般情况下操作系统会为每个进程分配固定栈空间的大小。

  堆需要动态申请额外的内存来存放相应的数据和变量。

- 申请后系统响应：栈空间，申请空间大于分配空间则分配成功，否则栈溢出。

  堆空间，堆在内存的呈现方式类似于链表，空闲地址的内存被用链表记录，在链表中申请第一个大于申请空间的节点分配给程序，然后将此节点在链表中删除。
  如果不对申请的内存进行释放，则堆上存储变量生存周期一直存在，知道进程退出。

- 线程安全：栈在内存中是一块连续的空间（向低地址扩展），最大容量是系统预订的，只能被当前线程访问。

  堆在内存中的空间（向高地址扩展）是不连续的，堆中的内存不是线程安全的，同一进程的线程都可以访问。

- 申请效率：栈是系统自动分配，申请效率高；堆是由程序员主动申请，效率低，使用方便但是易产生碎片。


### 实际的内存管理

- 操作系统按照段页式管理内存，创建新进程或线程时，操作系统为新的进程分配物理页，运行的进程需要更多的内存时，操作系统也会为其分配新的物理页并映射到该进程的虚拟地址空间中。

- 程序运行时，每个程序中含有一个内存管理的子程序，负责程序中的内存申请喝释放。

## 内存对齐

### 什么是内存对齐

  典型的例子

  ``` cpp
  struct {
      int x;
      char y;
  } s;
  ```
  打印`sizeof(s)`的结果为8 bytes，这就是内存对齐导致的。

  实际的计算机系统对基本的类型数据在内存中的位置有限制，要求数据的首地址值是某个数（通常是4或8的倍数），这就是所谓的内存对齐。

### 为什么要内存对齐

  大部分处理器不是按字节块来存取内存的，一般会以双字节、4字节、8字节、16字节甚至32字节来存取内存，上述这些存取单位称为 **内存存取粒度** 。

  32位的CPU，机器字长为4字节，数据总线宽度为32位，只能从地址为4的倍数的内存开始读取数据。

  若没有内存对齐机制，数据任意存放，将会增加CPU访问内存的次数。

### 内存对齐的规则

  每个特定平台上的编译器都有自己默认的‘对齐系数’。gcc中默认`#pragma pack(4)`

  - 基本类型的对齐值就是其sizeof值;

  - 结构体的对齐值是其成员的最大对齐值;

  - 编译器可以设置一个最大对齐值，怎么类型的实际对齐值是该类型的对齐值与默认对齐值取最小值得来。



