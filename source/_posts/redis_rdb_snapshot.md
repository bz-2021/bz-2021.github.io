---
title: 【Redis】内存快照
date: 2023-11-25 16:44:53
tags: [Redis, SQL]
---

AOF 日志在进行故障恢复时需要逐一把日志都执行一遍。如果日志非常多，Redis 恢复得很缓慢

Redis 可以将某一时刻的状态以文件的形式写到磁盘上，即使宕机，快照文件也不会丢失

在数据恢复时，可以直接把 RDB 文件读入内存，很快地完成恢复

还要考虑两个问题：

- 对哪些数据做快照
- 做快照时，数据还能被增删改吗，Redis 是否被阻塞

为了提供所有数据得可靠性保持，执行的是全量快照

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave

- save 在主线程中执行，会导致阻塞
- bgsave 创建子线程，专门用于写入 RDB 文件，避免了主线程的阻塞，也是 Redis RDB 文件生成的默认配置

通过 bgsave 进行快照时，可以避免主线程的阻塞，但是**避免阻塞和正常处理写操作并不是一回事**

为了快照的完整性，不能修改正在执行快照的数据，只能处理读操作

在这里 Redis 借助操作系统提供的写时复制技术（COW）在执行快照的同时，正常处理写操作

如果主线程要修改一块数据，那么这块数据就会被复制一份，生成副本，然后子进程会把这个副本写入 RDB 文件

### 多久做一次快照

两方面的开销

- 频繁将全量的数据写入磁盘，会给磁盘带来很大的压力，多个快照竞争有限的磁盘带宽，前一个未完后一个开始
- fork 主线程过程本身会阻塞主线程，主线程内存越大，阻塞时间越长

### 增量快照

做了一次全量快照之后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销

但是，我们需要记住哪些数据被修改了

和 AOF 相比，快照的恢复速度快，但是快照的频率不好把握

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法

在两次快照之间，使用 AOF 日志记录这期间的所有的命令操作

### 选择问题

- 数据不能丢失时，内存快照和 AOF 混合使用
- 允许分钟级别的数据丢失，可以只使用 RDB
- 如果只用 AOF，优先使用 everysec 因为它在可靠性和性能之间取了平衡